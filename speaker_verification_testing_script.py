# -*- coding: utf-8 -*-
"""Speaker_Verification_Testing_Script.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lyuVqM2UnVcJUY-e-yhcZzYvDAPGpEVs
"""

# Installation Instructions
# Ensure the following libraries are installed before running the script:
!pip install soundfile
!pip install noisereduce

# Import necessary libraries
import librosa  # For audio processing
import numpy as np  # For numerical operations
import scipy as sp  # For scientific computations
import scipy.signal  # For signal processing
import os  # For file operations
import pandas as pd  # For data manipulation
from scipy import stats  # For statistical functions
from sklearn.mixture import GaussianMixture  # For GMM-based modeling
import joblib  # For saving and loading models
import noisereduce as nr  # For noise reduction in audio
import soundfile as sf  # For working with audio files

# Function to denoise audio using noise reduction techniques
def denoise_audio(input_file):
    # Load audio file
    audio, sr = librosa.load(input_file, sr=None)

    # Step 1: Estimate the noise profile (using the first 1 second as noise)
    noise_sample = audio[:sr]  # Extract first second of audio as noise

    # Step 2: Apply noise reduction using the noise profile
    denoised_audio = nr.reduce_noise(y=audio, sr=sr, y_noise=noise_sample)

    return denoised_audio, sr  # Return denoised audio and sampling rate

# Function to extract audio features for modeling
def extract_features(audio, sr, n_mfcc=64):
    # Extract MFCC (Mel-frequency cepstral coefficients) features
    mfcc = librosa.feature.mfcc(y=audio, sr=sr, n_mfcc=n_mfcc)
    # Calculate the delta (rate of change) of the MFCCs
    delta = librosa.feature.delta(mfcc)
    # Calculate the delta-delta (acceleration) of the MFCCs
    delta2 = librosa.feature.delta(mfcc, order=2)
    # Combine MFCC, delta, and delta-delta into a single feature set
    combined = np.concatenate((mfcc, delta, delta2))
    return combined.T  # Transpose the array for easier modeling


# Function to predict the speaker of an audio file
def test(file_path, loaded_models):
    # Denoise the input audio file
    audio, sr = denoise_audio(file_path)
    # Extract features from the audio
    mfcc_data = extract_features(audio, sr)
    result = {}  # Dictionary to store speaker likelihood scores

    # Iterate through all loaded speaker models
    for speaker in loaded_models:
        # Calculate log-likelihood for the given features
        log_likelihoods = speaker.score_samples(mfcc_data)
        # Convert log-likelihood to probability and average over all frames
        result[speaker] = np.exp(np.mean(log_likelihoods))

    # Return the speaker with the maximum likelihood score
    return max(result, key=lambda k: result[k])

# Function to verify if two audio files belong to the same speaker
def verify(speaker1, speaker2, model_path):
    # Load speaker models from the specified path
    with open(model_path, "rb") as file:
        loaded_models = joblib.load(file)

    # Predict the speakers of the two input audio files
    speaker1 = test(speaker1, loaded_models)
    speaker2 = test(speaker2, loaded_models)

    # Check if the two predicted speakers are the same
    if speaker1 == speaker2:
        return True  # The speakers match
    else:
        return False  # The speakers do not match


if __name__ == "__main__":
  verify('speaker1', 'speaker2', 'model.pkl')  #speaker1, speaker2, model.pkl

